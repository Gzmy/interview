
#### 快排时间复杂度？与其他的排序相比为什么大工程都会使用快排
- 最好O(N*LogN)，最坏O(N^2)
- 与堆排相比，快排的最坏时间复杂度和平均时间复杂度都不如
	堆排，但是快排在实际应用中却比堆排好很多这是为什么
	- 经过实验，会发现相同的数据规模，快速排序比堆排序的效率高很多，
	并且随着数据规模的扩大，二者的差距不断扩大，快速排序的优势越来越明显。
	快速排序的时间复杂度近似线性增长，堆排序则要大很多
	-  在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，
	再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，
	而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，
	最后一个元素很有可能最终再被移动到底部。在堆排序里面有大量这种近乎无效的比较。
	随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，
	如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的10log10倍。
	- 堆排序的过程中，需要有效的随机存取。比较父节点和字节点的值大小的时候，虽然计算下标会很快完成，
	但是在**大规模的数据中对数组指针寻址也需要一定的时间。而快速排序只需要将数组指针移动到相邻的区域即可。**
	在堆排序中，会大量的随机存取数据；而在快速排序中，只会大量的顺序存取数据。随着数据规模的扩大，
	这方面的差距会明显增大。在这方面的时间开销来说，快速排序只会线性增长，
	而堆排序增加幅度很大，会远远大于线性。
	- 在快速排序中，每次数据移动都意味着该数据距离它正确的位置越来越近，而在堆排序中，
	类似将堆尾部的数据移到堆顶这样的操作只会使相应的数据远离它正确的位置，
	后续必然有一些操作再将其移动，即“做了好多无用功”。
- 附:各排序的时间复杂度分析
	- 排序方法|最好时间复杂度|最坏时间复杂度|平均时间复杂度|空间复杂度|稳定性
	  :-: | :-: | :-: | :-: | :-: | :-:
	  插入排序|O(N)|O(N^2)|O(N^2)|O(1)|稳定
	  Shell排序|O(N)|O(N^2)|O(N^1.3)|O(1)|不稳定
	  冒泡排序|O(N)|O(N^2)|O(N^2)|O(1)|稳定
	  选择排序|O(N^2)|O(N^2)|O(N^2)|O(1)|不稳定
	  堆排|O(N*LogN)|O(N*logN)|O(N*LogN)|O(1)|不稳定
	  快排|O(N*LogN)|O(N^2)|O(N*LogN)|O(LogN)|不稳定
	  归并|O(N*LogN)|O(N*logN)|O(N*LogN)|O(N)|稳定

#### Linux inode
 - 文件存储在硬盘中，硬盘的**最小存储单位**叫做“扇区”，每个扇区512个字节(0.5KB)
 操作系统读取硬盘时，不会一个个扇区读，这样效率太低，而是一次性连续读取
 一个块。这种有多个扇区组成的块，是**文件存取的最小单位**，块的大小最常见的是4KB
 即连续八个扇区组成一个块
 - 文件数据都存储在块中，我们就必须得找到一个地方存储文件的元信息，比如文件的创建者，
 文件创建日期，文件大小等等，这个存储文件元信息的区域就是inode
 - inode也会消耗硬盘空间，所以硬盘格式化时，操作系统自动将硬盘分成两个区域，
 一个数据区存储文件数据，一个inode区存储文件所包含的信息
 - 每个inode节点的大小一般是128字节或者256字节，inode结点的总数一般在格式化时就已经给定
 一般是每1KB或者2KB就设置一个inode
 - 每个inode都有一个号码。操作系统用inode来识别不同的文件，用户打开文件分三步：
   - 系统找到这个文件对应的inode
   - 其次通过inode号获取inode信息
   - 根据inode信息找到文件数据对应的block，读出数据
 - 目录文件结构就是一系列目录项的列表，每个目录项都由两部分组成：所包含的文件名，以及该文件名所对应的inode
 - 常用命令
 
	  ```
	  stat file-name :
	  df -i : 查看每个分区的inode总数和已经使用的数量
	  sudo dumpe2fs -h /dev/hda | grep "Inode size" : 查看每个结点的inode大小
	  ln 源文件 目标文件 : 创建硬链接
	  ln -s 源文件或目录 目标文件 : 创建软连接
	  ```

#### 静态库和动态库的优缺点
	
- 静态库 : .a
	- 库中所有文件将被程序使用的函数机器码copy到最终的可执行文件中，导致最终生成的可执行代码量相对较多
	但是运行起来相对能快一点，**不过会占用磁盘和内存空间**

- 动态库 : .so
	- 与共享库连接的可执行文件中只需要包含它所需要的函数引用表，而不是所有的函数执行代码
	只有在执行中，那些函数才拷贝到内存中，这样就使可执行文件比较小，节省磁盘空间，更进一步，
	操作系统使用虚拟内存，是的一份共享库驻留在内存中被多个可执行文件爱你使用，节约了内存，
	不过运行时连接库需要花费一定量的时间，执行速度会相对慢一点，

- 总体来说**静态库是牺牲空间换时间，动态库牺牲时间换空间**，
	- 一个程序编译好了之后，有时需要做一些修改和优化，如果刚好改的是库函数，在接口不变的前提下，
	使用动态库的程序只需要重新编译，但是使用静态库就需要将静态库重新编译
	- 
	```
	静态库生成: g++ -c filename.cc -o filename.o
				ar -arc libfilename.a filename.o
	动态库生成: g++ -fIPC -c filename.cc -o filename.o
				g++ -shared -o libfilename.so filename.o
			or :g++ -fIPC -shared -o libfilename.so filename.cc

	-I : 指定库文件的头文件所在目录
	-L : 指定库路径
	-l : 连接库名
	```


