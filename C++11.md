# C++中的类型转换
- 标准C++为了加强类型转换的可视性,引入四种命名的强制类型转换操作符
`static_cast, reinterpret_cast, const_cast, dynamic_cast`


### `static_cast`转换
- static_cast用于非多态类型的转换(静态转换),
	编译器隐式执行的任何类型转换都可以用static_cast,不能用于两个不相关的类型进行转换
- 用于类层次结构中的基类和派生类之间的转换
	- 上行转换(派生类 --> 基类)是安全的
	- 下行转换(基类 --> 派生类)没有动态的类型检查, 是不安全的
- 用于基本数据类型之间的转换, 比如把int转为char, 这个安全性需要开发者维护
- 将空指针转换成目标类型的空指针
- 将任何类型的表达式转成void类型
- 主要用于非多态的转换操作

```
int main()
{
	double d = 12.34;
	int a = static_cast<int>(d);
	std::cout << a << std::endl;
	return 0;
}
```


### `dynamic_cast`运行时转换
- `dynamic_cast`是运行时处理, 运行时需要进行类型检查, 不能用于内置类型的数据转换
- 转换成功返回指向类的指针或者引用, 失败返回NULL
- 使用`dynamic_cast`进行转换的, 基类中一定要有虚函数, 否则编译失败
- `dynamic_cast`用于将一个父类对象指针转换为子类对象的指针或者引用(动态转换)
	向上转型: 子类对象指针->父类指针/引用(不需转换,赋值兼容规则)
	向下转型: 父类对象指针->子类指针/引用(用dynamic_cast是安全的)
-   注: 1.dynamic_cast只用于含有虚函数的类,
		2.dynamic_cast会先检查能否转换成功,能转换则转换,不能则返回NULL

### `const_cast`转换
- 常量指针转换成为非常量指针, 并且仍然指向原来的对象
- 常量引用转换成为非常量引用, 并且仍然指向原来的对象
- 一个使用场景: 非常量函数调用const_cast<const T>将参数转换成非常量引用,
	调用常量函数, 得到结果再通过const_cast<T>去除常量属性
```
void test() {
	const int a = 2;
	int* p = const_cast<int*>(&a);
	*p = 3;

	std::cout << a << std::endl;
}
```
### `reinterpret_cast`转换
- `reinterpret_cast`是从底层对数据结构进行重新解释, 依赖具体的平台, 可移植性差
- `reinterpret_cast`可以讲整形转换为指针, 也可以把指针转换成数组
- `reinterpret_cast`可以在指针和引用里进行肆无忌惮的转换

- 强制类型转换关闭或者挂起了正常的类型检查,每次使用强制类型转换前,
	用户应该仔细考虑是否还有其他不同的方法达到同一目的,如果非强制转换不可
	可以限制强制转换值的作用域,减少错误的发生机会

# C++11新特性
- C++11支持列表初始化

	```
	std::vector<int> v{1, 2, 3, 4, 5};
	int *arr = new int[5]{1, 2, 3, 4, 5};
	// 自定义类型
	Pointer p{1,2};
	```
- 变量类型推倒

	- `auto`: 必须对auto的声明类型进行初始化,否则编译器无法推倒出auto的实际类型,
		有时候需要根据表达式运行完成之后的结果类型进行推倒,编译期间代码不会运行,auto无能为力
	- `decltype`: 根据表达式的实际类型推演出定义变量时所用类型

		```
		int a = 10;
		int b = 20;
		decltype(a+b) c;

		struct {
			int _x;
			int _y;
		} pt;
		
		decltype(pt) p;
		```

	- 基于范围for循环

	- final与override

	- 委派构造函数
		- 在初始化列表中调用基准版本的构造函数称为委派构造函数,而被调用的"基准版本"
		则称为目标构造函数

	- 默认函数控制
		- C++11中可以在默认函数定义或者声明时加上=default,从而显示的指示编译器
		生成该函数的默认版本,用=default修饰的函数称为显式缺省函数
		- 删除默认函数: =delete, 避免编译器做一些不必要的隐式类型转换
	
	- 右值引用
		> 纯右值: 用于识别一些临时和一些不跟对象关联的值, 常量,一些运算表达式
		> 将亡值: 声明周期将要结束的对象, 在值返回的临时对象

		- 类型&& 引用变量名 = 实体;
		- std::move(), 将一个左值强制转化为右值引用,被转化的左值,其声明周期没有随左右值的转化而变化
	- lambda表达式
	- thread线程库
