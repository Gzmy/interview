# 此文章整理字节跳动面试题

## 编程语言和算法
- 找出数组中只出现一次的数(核心思想是异或)
- BST中任意链各个结点差的最小值
- 判断二叉树是否中心对称
- 大数相乘
- 堆排序(构建堆,每次去最后一个与堆顶元素交换,重新调整)
- 智能指针的循环引用, 除了weak_ptr还有其他的解决办法?
- vector扩容的时间复杂度 

## 操作系统和网络
- IO多路复用的优缺点
- tcp拥塞控制, 三次握手, 四次挥手


## 数据库(头条重点)
- 乐观锁和悲观锁
	- 悲观锁:总是假设最坏的情况,每次去拿数据时都认为别人会修改,每次拿数据时
	都会上锁,别人想拿数据都必须阻塞等到它拿到锁.行锁,表锁,读锁,写锁都是在做
	操作之前先上锁
	- 乐观锁:总是假设最好的情况,每次去拿数据都任务别人不会修改数据,所以不会上锁
	但是在更新时会判断在此期间别人有没有去更新这个数据.**多适用于多读的应用类型,
	提高吞吐量**
	- 附:乐观锁实现的两种机制   版本号机制和CAS算法
	> 版本号机制: 一般是在数据表中加上一个数据版本号version字段用于表示数据被修改的次数
	> 当数据被修改,version+1, 当线程A要更新数据,在读取数据的同时也会读取version值,在提交更新时
	> 此时的version值和刚才读的值相等才更新,否则重试更新,直到更新成功
	> CAS算法(compare and swap): 是一种无锁算法,不使用锁实现多线程之间的变量同步.
	>	CAS涉及到三个操作数: 需要读写的内存值V, 尽心比较的值A, 拟写入的新值B
	> 当且仅当V的值是A时,CAS会通过原子方式用新值B来更新V的值,否则不会执行任何操作

	- 使用场景:乐观锁适用于多读,悲观锁适用于多写
- BTREE索引和HASH索引的比较
	- HASH索引只能使用=或者<= >=操作符的等式比较, 如果一定要使用范围查询,只能使用BTREE索引
	- 优化器不能使用HASH索引来加速order by操作
	- 使用HASH索引时MySQL不能确定在两个值之间大概有多少行,如果将一个MyISAM表
	改为HASH索引的memory表,会影响一些查询的执行效率
	- HASH索引只能使用整个关键字来搜索一行
- 隔离以及隔离级别
	- 读未提交, 读已提交, 可重复读, 串行化
- 事物的ACID
	- 原子性, 一致性, 持久性, 隔离性 
- 视图
- 聚簇索引
	- 主索引文件和数据文件是同一份文件, 主要应用在Innodb引擎上, 
	索引实现方式中B+树的叶子节点上的data就是数据本身, key为主键, 
	- B+树的每个叶子节点上增加一个指向相邻叶子节点的指针, 就形成
	了带有顺序访问指针的B+ Tree, 提高区间的访问性能
- 非聚簇索引
	- B+树的叶子节点上的data不是数据本身, 而是数据存放的地址, 与聚簇相比
	  主要应用在MyISAM上, 多了一次读取数据IO的操作, 查找性能较差
- MyISAM和InnoDB比较
	- MyISAM支持全文索引(仅英文), 压缩索引, InnoDB不支持
	- InnoDB支持事物, MyISAM不支持
	- MyISAM顺序存储数据, 索引叶子结点保存对应数据行地址, 辅助索引跟主键索引没有多大区别
	  InnoDB主键结点同时保存数据行, 其他辅助索引保存主键索引的值
	- MyISAM键值分离, 索引载入内存, 数据缓存依赖操作系统, 
	  InnoDB键值一起保存, 索引与数据一起载入InnoDB缓冲池,
	- MyISAM索引的基数值是精确的, InnoDB是估计值
- 为什么选用B+Tree
	- 一般来说, 索引本身也很大, 不可能全部存储在内存中, 因此索引往往以索引文件
	  的形式存储在磁盘上, 这样的话, 索引查找过程就要产生磁盘I/O消耗,相对于内存存取
	  I/O存取的消耗要高几个数量级, 索引评价一个数据结构作为索引的优劣最重要的指标
	  就是在查找过程中磁盘I/O操作次数的渐进复杂度, 
	- 内存是一系列的存储单元组成, 每个存储单元存储固定大小的数据, 并且有一个唯一的地址
	  当需要读取内存时, 将地址信号放到地址总线上传给内存, 内存解析信号并定位到
	  存储单元, 然后把该存储单元上的数据放到数据总线上进行回传
	- 写内存时, 系统将要写入的数据和单元地址分别放到数据总线和地址总线上
	  内存读取两个总线内容, 进行写操作
	- 内存存取的效率与次数有关, 先读取A还是后读取A不会影响存取效率, 读取磁盘就不一定, 
	  磁盘I/O涉及到机械操作, 磁盘是由大小相同并且同轴的圆形盘片组成, 磁盘可以转动
	  磁盘的一侧有磁头支架, 磁头支架固定一磁头, 每个磁头负责存取一个磁盘内容,
	  磁头不动, 磁盘转动, 磁臂可以前后转动, 用于读取不同磁道上的数据, 磁道又划分
	  一个个小段, 叫做扇区
	- 磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址，
	  即哪个磁道哪个扇区。于是磁头需要前后移动到对应的磁道，消耗的时间叫寻道时间，
	  然后磁盘旋转将对应的扇区转到磁头下，消耗的时间叫旋转时间。所以，
	  适当的操作顺序和数据存放可以减少寻道时间和旋转时间。
	- 为了尽量减少I/O操作，磁盘读取每次都会预读，大小通常为页的整数倍。
	  即使只需要读取一个字节，磁盘也会读取一页的数据(通常为4K)放入内存，
	  内存与磁盘以页为单位交换数据。因为局部性原理认为，通常一个数据被用到，
	  其附近的数据也会立马被用到。
	- B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，
	  把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，
	  完成这次检索操作，最多需要3次I/O(根节点常驻内存)。
	  数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。

	- B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，
	  树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。



## redis
- redis的单进程单线程模型
- redis支持的数据类型
- redis中的字符串类型如何实现

