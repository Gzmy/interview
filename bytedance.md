# 此文章整理字节跳动面试题

## 编程语言和算法
- 找出数组中只出现一次的数(核心思想是异或)
- BST中任意链各个结点差的最小值
- 判断二叉树是否中心对称
- 大数相乘
- 堆排序(构建堆,每次去最后一个与堆顶元素交换,重新调整)
- 智能指针的循环引用, 除了weak_ptr还有其他的解决办法?
- vector扩容的时间复杂度 

## 操作系统和网络
- IO多路复用的优缺点
- tcp拥塞控制, 三次握手, 四次挥手

- 进程调度方式
	- 可抢占式: 就绪队列中一旦有某进程的优先级高于当前正在执行的进程优先级
	操作系统立即进行调度, 完成进程切换
	- 不可抢占式: 即使在就绪队列中的谋个优先级高于当前正在执行进程的优先级,
	当前进程仍将占用处理器执行,直到该进程自己进入阻塞状态或者时间片已用完,
	正在执行完系统调用后准备返回用户进程前的时刻,才重新发生调度.

- 进程调度算法
	- 先来先服务(FCFS), 采用不可抢占式调度方法
	- 短作业优先(SJF), 估计最短的执行时间, 可以采用抢占式也可以非抢占
	- 时间片轮转(RR), 每个进程都有一定的运行时间, 超过时间就停止运行让出CPU
	- 高相应比优先(HRRF), 介于先来先服务和短作业优先中的一种折中算法, 既考虑进程的等待时间, 也考虑进程的执行时间
	- 多级反馈队列(MLFQ), 设置多个就绪队列, 优先级越高的时间片越小
	- 最高优先级优先调度算法, 使用静态优先级和动态优先级

- 进程调度时机
	- 正在执行的进程执行完毕, 选择新的就绪进程开始执行
	- 正在执行的进程调用相关的系统调用(包括I/O操作,同步与互斥等)导致需要
	等待某些事件的发生或者可用资源将自己阻塞
	- 正在执行的进程主动放弃CPU的系统调用, 使自己变为就绪状态进入到就绪队列之中
	- 等待事件发生成功导致进程从阻塞态回到就绪态进入到就绪队列之中
	- 正在执行的进程时间片已用完变为就绪态
	- 正在执行完毕系统调用之后准备返回用户进程前的时刻
	- 就绪队列中的某个优先级变得高于当前进程的优先级

- http长连接和短连接
- fork时内存空间发生了哪些变化
	- 父子进程的页表项都指向同一个代码段
	- 使用写时拷贝最大化的提高内存的使用效率,当有修改意图时,内核捕获父进程或者
	子进程对共享页面的修改企图, 系统创建新的页面分配给被内核捕获的进程,现在可以修改各自的数据段, 堆栈段

- 进程创建的写时拷贝以及进程直接的转换
- 进程的信号处理流程 等待状态的进程是否可以接收信号
- 死锁 死锁条件 避免死锁 死锁检测 死锁预防


## 数据库(头条重点)
- 乐观锁和悲观锁
	- 悲观锁:总是假设最坏的情况,每次去拿数据时都认为别人会修改,每次拿数据时
	都会上锁,别人想拿数据都必须阻塞等到它拿到锁.行锁,表锁,读锁,写锁都是在做
	操作之前先上锁
	- 乐观锁:总是假设最好的情况,每次去拿数据都任务别人不会修改数据,所以不会上锁
	但是在更新时会判断在此期间别人有没有去更新这个数据.**多适用于多读的应用类型,
	提高吞吐量**
	- 附:乐观锁实现的两种机制   版本号机制和CAS算法
	> 版本号机制: 一般是在数据表中加上一个数据版本号version字段用于表示数据被修改的次数
	> 当数据被修改,version+1, 当线程A要更新数据,在读取数据的同时也会读取version值,在提交更新时
	> 此时的version值和刚才读的值相等才更新,否则重试更新,直到更新成功
	> CAS算法(compare and swap): 是一种无锁算法,不使用锁实现多线程之间的变量同步.
	>	CAS涉及到三个操作数: 需要读写的内存值V, 尽心比较的值A, 拟写入的新值B
	> 当且仅当V的值是A时,CAS会通过原子方式用新值B来更新V的值,否则不会执行任何操作

	- 使用场景:乐观锁适用于多读,悲观锁适用于多写
- BTREE索引和HASH索引的比较
	- HASH索引只能使用=或者<= >=操作符的等式比较, 如果一定要使用范围查询,只能使用BTREE索引
	- 优化器不能使用HASH索引来加速order by操作
	- 使用HASH索引时MySQL不能确定在两个值之间大概有多少行,如果将一个MyISAM表
	改为HASH索引的memory表,会影响一些查询的执行效率
	- HASH索引只能使用整个关键字来搜索一行
- 隔离以及隔离级别
	- 读未提交, 读已提交, 可重复读, 串行化
- 事物的ACID
	- 原子性, 一致性, 持久性, 隔离性 
- 视图
- 聚簇索引
	- 主索引文件和数据文件是同一份文件, 主要应用在Innodb引擎上, 
	索引实现方式中B+树的叶子节点上的data就是数据本身, key为主键, 
	- B+树的每个叶子节点上增加一个指向相邻叶子节点的指针, 就形成
	了带有顺序访问指针的B+ Tree, 提高区间的访问性能
- 非聚簇索引
	- B+树的叶子节点上的data不是数据本身, 而是数据存放的地址, 与聚簇相比
	  主要应用在MyISAM上, 多了一次读取数据IO的操作, 查找性能较差

- InnoDB
	- 默认的事务型存储引擎
	- 实现了四个标准的隔离级别, 默认级别是可重复读. 通过多版本并发
	控制MVCC和间隙锁防止幻影读
	- 主索引是聚簇索引, 在索引中保存数据, 避免直接读取磁盘, 对查询性能有提升

- MyISAM和InnoDB比较
	- MyISAM支持全文索引(仅英文), 压缩索引, InnoDB不支持
	- InnoDB支持事物, MyISAM不支持
	- MyISAM顺序存储数据, 索引叶子结点保存对应数据行地址, 辅助索引跟主键索引没有多大区别
	  InnoDB主键结点同时保存数据行, 其他辅助索引保存主键索引的值
	- MyISAM键值分离, 索引载入内存, 数据缓存依赖操作系统, 
	  InnoDB键值一起保存, 索引与数据一起载入InnoDB缓冲池,
	- MyISAM索引的基数值是精确的, InnoDB是估计值
	- 事务: InnoDB是事务型, 可以使用Commit和Rollback
	- 并发: MyISAM只支持表级锁, InnoDB支持行级锁
	- 外键: InnoDB支持
	- 备份: InnoDB支持在线热备份
	- 崩溃恢复: MyISAM崩溃后的损坏概率比InnoDB高很多, 恢复速度也更慢
	- 其他: MyISAM支持压缩表和空间数据压缩
- 为什么选用B+Tree
	- 一般来说, 索引本身也很大, 不可能全部存储在内存中, 因此索引往往以索引文件
	  的形式存储在磁盘上, 这样的话, 索引查找过程就要产生磁盘I/O消耗,相对于内存存取
	  I/O存取的消耗要高几个数量级, 索引评价一个数据结构作为索引的优劣最重要的指标
	  就是在查找过程中磁盘I/O操作次数的渐进复杂度, 
	- 内存是一系列的存储单元组成, 每个存储单元存储固定大小的数据, 并且有一个唯一的地址
	  当需要读取内存时, 将地址信号放到地址总线上传给内存, 内存解析信号并定位到
	  存储单元, 然后把该存储单元上的数据放到数据总线上进行回传
	- 写内存时, 系统将要写入的数据和单元地址分别放到数据总线和地址总线上
	  内存读取两个总线内容, 进行写操作
	- 内存存取的效率与次数有关, 先读取A还是后读取A不会影响存取效率, 读取磁盘就不一定, 
	  磁盘I/O涉及到机械操作, 磁盘是由大小相同并且同轴的圆形盘片组成, 磁盘可以转动
	  磁盘的一侧有磁头支架, 磁头支架固定一磁头, 每个磁头负责存取一个磁盘内容,
	  磁头不动, 磁盘转动, 磁臂可以前后转动, 用于读取不同磁道上的数据, 磁道又划分
	  一个个小段, 叫做扇区
	- 磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址，
	  即哪个磁道哪个扇区。于是磁头需要前后移动到对应的磁道，消耗的时间叫寻道时间，
	  然后磁盘旋转将对应的扇区转到磁头下，消耗的时间叫旋转时间。所以，
	  适当的操作顺序和数据存放可以减少寻道时间和旋转时间。
	- 为了尽量减少I/O操作，磁盘读取每次都会预读，大小通常为页的整数倍。
	  即使只需要读取一个字节，磁盘也会读取一页的数据(通常为4K)放入内存，
	  内存与磁盘以页为单位交换数据。因为局部性原理认为，通常一个数据被用到，
	  其附近的数据也会立马被用到。
	- B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，
	  把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，
	  完成这次检索操作，最多需要3次I/O(根节点常驻内存)。
	  数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。

	- B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，
	  树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。

- 索引的优点
	- 大大减少服务器需要扫描数据行
	- 帮助服务器避免进行排序和分组, 以及避免创建临时表(索引有序,可以用于
			ORDER BY和GROUP BY操作,临时表是在排序和分组时创建, 索引不需要)
	- 将随机I/O变为顺序I/O(B+Tree索引是有序的,会将相邻的数据存储在一起)

- 索引使用条件
	- 对于非常小的表, 大部分情况简单的全表扫描比建立索引更高效
	- 对于中到大型的表, 索引非常有效
	- 对于特大型的表, 建立和维护索引的代价会随之增长. 可以使用分区技术

- 索引优化
	- 多列索引: 在需要使用多个列作为条件查询时, 使用多列索引比使用单个索引性能更好
	- 索引列的顺序: 让选择性最强的索引列放在前面. 选择性强(不重复的索引值和记录总数的比值)
	- 前缀索引:
	- 覆盖索引:
	

	
- 索引的使用条件 优化以及最左原则



## redis
- redis的单进程单线程模型
- redis支持的数据类型
- redis中的字符串类型如何实现

